name: Run Gradio app until ready

inputs:
  script:
    required: true
  project:
    required: true
  timeout:
    required: false
    default: 3600

runs:
  using: 'composite'
  steps:
    - name: Run Gradio App
      shell: bash
      run: |
        cd ${{ inputs.project }}

        if [ "${{ runner.os }}" == "Linux" ]; then
          xvfb-run python ${{ inputs.script }} 2>&1 | tee gradio_log.txt &
        else
          python ${{ inputs.script }} 2>&1 | tee gradio_log.txt &
        fi
        
        # Give the app a moment to start
        sleep 1
        
        # Debug: list python processes running your script
        echo "Listing python processes running the script:"
        ps aux | grep "[p]ython .*${{ inputs.script }}" || echo "No matching python processes found."
        
        # Find the PID of the python process running your script
        app_pid=$(pgrep -f "python .*${{ inputs.script }}" | head -n1)
        echo "App PID: $app_pid"
        
        # Wait for the specific log message or timeout
        timeout ${{ inputs.timeout }} bash -c "
          (tail -f gradio_log.txt &) | awk '/Demo is ready!/ {exit}'
        "
        
        status=$?
        echo "Timeout exit code: $status"
        
        # Show last lines of the log for debugging
        echo "Last 20 lines of log:"
        tail -n 20 gradio_log.txt
        
        # Stop the Gradio app if still running
        if kill -0 $app_pid 2>/dev/null; then
          echo "Stopping the Gradio app..."
          pkill -P $app_pid || echo "No child processes to kill."
          kill $app_pid || echo "App process already terminated."
          wait $app_pid || echo "App process cleanup complete."
        else
          echo "App process $app_pid already stopped."
        fi
        
        exit $status
