name: Run Gradio app until ready

inputs:
  script:
    required: true
  project:
    required: true
  timeout:
    required: false
    default: 3600

runs:
  using: 'composite'
  steps:
    - name: Run Gradio App (Linux/Mac)
      if: ${{ runner.os != 'Windows' }}
      shell: bash
      run: |
        cd ${{ inputs.project }}

        if [ "${{ runner.os }}" == "Linux" ]; then
          # Start the Gradio app in the background
          xvfb-run python ${{ inputs.script }} 2>&1 | tee gradio_log.txt &
        else
          python ${{ inputs.script }} 2>&1 | tee gradio_log.txt &
        fi

        # Assign process ID
        app_pid=$(ps aux | grep -i '[p]ython ${{ inputs.script }}' | awk '{print $2}')

        # Wait for the specific log message
        timeout ${{ inputs.timeout }} bash -c "
          (tail -f gradio_log.txt &) | awk '/Demo is ready!/ {exit}'
        "

        # Capture the readiness status
        status=$?

        # Stop the Gradio app process
        echo "Stopping the Gradio app..."
        pkill -P $app_pid || echo "No child processes to kill."
        kill $app_pid || echo "App process already terminated."
        wait $app_pid || echo "App process cleanup complete."

        # Exit with the readiness check status
        exit $status

    - name: Run Gradio App (Windows)
      if: ${{ runner.os == 'Windows' }}
      shell: pwsh
      run: |
        cd ${{ inputs.project }}
        Write-Output "==> Running script: ${{ inputs.script }}"
    
        $timeout = [int]${{ inputs.timeout }}
        $start_time = Get-Date
        $success = $false
    
        # Prepare log files
        New-Item -Path gradio_stdout.txt -ItemType File -Force | Out-Null
        New-Item -Path gradio_stderr.txt -ItemType File -Force | Out-Null
    
        # Setup process info
        $psi = New-Object System.Diagnostics.ProcessStartInfo
        $psi.FileName = "python"
        $psi.Arguments = "${{ inputs.script }}"
        $psi.RedirectStandardOutput = $true
        $psi.RedirectStandardError = $true
        $psi.UseShellExecute = $false
        $psi.CreateNoWindow = $true
        $psi.WorkingDirectory = (Get-Location).Path
    
        $proc = New-Object System.Diagnostics.Process
        $proc.StartInfo = $psi
    
        # Event handlers for async output reading
        $stdOutBuilder = New-Object System.Text.StringBuilder
        $stdErrBuilder = New-Object System.Text.StringBuilder
    
        $outputEvent = [System.Diagnostics.DataReceivedEventHandler]{
            param($sender, $args)
            if ($args.Data) {
                $line = $args.Data
                $line | Tee-Object -FilePath gradio_stdout.txt -Append | Write-Output
                if ($line -match "Demo is ready!") {
                    $global:success = $true
                    $proc.Kill()
                }
            }
        }
    
        $errorEvent = [System.Diagnostics.DataReceivedEventHandler]{
            param($sender, $args)
            if ($args.Data) {
                $line = $args.Data
                $line | Tee-Object -FilePath gradio_stderr.txt -Append | Write-Error
            }
        }
    
        $proc.add_OutputDataReceived($outputEvent)
        $proc.add_ErrorDataReceived($errorEvent)
    
        $proc.Start() | Out-Null
        $proc.BeginOutputReadLine()
        $proc.BeginErrorReadLine()
    
        # Poll for timeout or process exit
        while (-not $proc.HasExited) {
            if (((Get-Date) - $start_time).TotalSeconds -ge $timeout) {
                Write-Output "==> Timeout waiting for readiness."
                $proc.Kill()
                break
            }
            Start-Sleep -Milliseconds 200
        }
    
        $proc.WaitForExit()
    
        Write-Output "==> Gradio Log Output:"
        if (Test-Path gradio_stdout.txt) { Get-Content gradio_stdout.txt }
        if (Test-Path gradio_stderr.txt) { Get-Content gradio_stderr.txt }
    
        if (-not $global:success) { exit 1 }
